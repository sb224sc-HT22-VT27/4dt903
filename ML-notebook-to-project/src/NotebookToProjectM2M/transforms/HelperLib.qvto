import CodeClassificationLib;

library HelperLib;

modeltype NotebookMM uses "http://www.g7.org/notebookMM";
modeltype ProjectStuctureMM uses "http://www.g7.org/projectStructureMM";

/**
 * Returns a Sequence of Strings representing the code of the given notebook.
 * @return Sequence(String)
 */
helper generateMainPyContent(notebook : NotebookMM::NotebookModel) : Sequence(String) {
    var contentLines : Sequence(String) := Sequence{};

    // Iterate through all cells in order
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::MarkdownCell) then {
            // Convert markdown cell to Python docstring
            var mdCell := cell.oclAsType(NotebookMM::MarkdownCell);
            if mdCell.content <> null and mdCell.content <> '' then {
                contentLines += '\n"""\n' + mdCell.content + '\n"""\n\n';
            } endif;
        } else if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            // Add code cell source as-is
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' then {
                contentLines += '\n' + codeCell.source + CodeClassificationLib::getClassificationCommentQVTo() + '\n\n';
            } endif;
        } endif endif;
    };

    return contentLines;
}

/**
 * Returns an OrderedSet of String names of imported packages in python for pip to install.
 * @return OrderedSet(String)
 */
helper extractPackageNames(notebook : NotebookMM::NotebookModel) : OrderedSet(String) {
	var imports : OrderedSet(String) := notebook.getAllImports();
	var packages : OrderedSet(String) := 
		imports 
		->collect(importStmt | mapImportToPackage(importStmt)) 
		->select(pkg | pkg <> '') 
		->asOrderedSet(); 
	
	return packages;
}

/**
 * Returns the assumed String name of a package.
 * @return String
 */
helper mapImportToPackage(importStmt : String) : String {
	if importStmt.indexOf('sklearn') > 0 then
	return 'scikit-learn'
	elif importStmt.indexOf('cv2') > 0 then
	return 'opencv-python'
	elif importStmt.indexOf('PIL') > 0 then
	return 'Pillow'
	elif importStmt.indexOf('pandas') > 0 then
	return 'pandas'
	elif importStmt.indexOf('numpy') > 0 then
	return 'numpy'
	elif importStmt.indexOf('matplotlib') > 0 then
	return 'matplotlib'
	elif importStmt.indexOf('scipy') > 0 then
	return 'scipy'
	elif importStmt.indexOf('seaborn') > 0 then
	return 'seaborn'
	elif importStmt.indexOf('joblib') > 0 then
	return 'joblib'
	elif importStmt.indexOf('tensorflow') > 0 then
	return 'tensorflow'
	elif importStmt.indexOf('torch') > 0 then
	return 'torch'
	elif importStmt.indexOf('keras') > 0 then
	return 'keras'
	elif importStmt.indexOf('flask') > 0 then
	return 'flask'
	elif importStmt.indexOf('django') > 0 then
	return 'django'
	elif importStmt.indexOf('requests') > 0 then
	return 'requests'
	elif importStmt.indexOf('sqlalchemy') > 0 then
	return 'sqlalchemy'
	elif importStmt.indexOf('pytest') > 0 then
	return 'pytest'
	elif importStmt.indexOf('yaml') > 0 then
	return 'PyYAML'
	elif importStmt.indexOf('bs4') > 0 then
	return 'beautifulsoup4'
	elif importStmt.indexOf('dateutil') > 0 then
	return 'python-dateutil'
	else
	return ''
	endif
}

/**
 * Returns a Sequence of Strings representing the content of a Dockerfile.
 * The Dockerfile sets up a Python venv, installs requirements, and runs main.py.
 * Uses the Python version from notebook metadata if available, defaults to 3.13-slim.
 * @return Sequence(String)
 */
helper generateDockerfileContent(notebook : NotebookMM::NotebookModel) : Sequence(String) {
	var dockerImage : String := mapPythonVersionToDockerImage(notebook);
	return Sequence{
		'FROM ' + dockerImage,
		'',
		'WORKDIR /app',
		'',
		'# Copy project files',
		'COPY requirements.txt .',
		'COPY src/ ./src/',
		'COPY data/ ./data/',
		'COPY models/ ./models/',
		'COPY outputs/ ./outputs/',
		'',
		'# Set up virtual environment and install dependencies',
		'RUN python -m venv /opt/venv',
		'ENV PATH="/opt/venv/bin:$PATH"',
		'RUN pip install --upgrade pip',
		'RUN pip install -r requirements.txt',
		'',
		'# Run the main script',
		'CMD ["python", "src/main.py"]'
	};
}

/**
 * Maps a Python version from notebook metadata to a valid Docker image tag.
 * Extracts major.minor version and maps to python:X.Y-slim format.
 * Defaults to python:3.13-slim if version cannot be mapped.
 * @return String - Docker image name with tag (e.g., 'python:3.11-slim')
 */
helper mapPythonVersionToDockerImage(notebook : NotebookMM::NotebookModel) : String {
	var defaultImage : String := 'python:3.13-slim';
	
	// Check if metadata and pythonVersion exist
	if notebook.metadata = null then
		return defaultImage
	endif;
	
	var version : String := notebook.metadata.pythonVersion;
	if version = null or version = '' then
		return defaultImage
	endif;
	
	// Extract major.minor version (e.g., "3.11.5" -> "3.11")
	var majorMinor : String := extractMajorMinorVersion(version);
	if majorMinor = '' then
		return defaultImage
	endif;
	
	// Map to supported Docker image versions
	// Official Python Docker images exist for: 3.8, 3.9, 3.10, 3.11, 3.12, 3.13
	if majorMinor = '3.8' or majorMinor = '3.9' or majorMinor = '3.10' or 
	   majorMinor = '3.11' or majorMinor = '3.12' or majorMinor = '3.13' then
		return 'python:' + majorMinor + '-slim'
	else
		return defaultImage
	endif;
}

/**
 * Extracts major.minor version from a full version string.
 * E.g., "3.11.5" -> "3.11", "3.13.7" -> "3.13"
 * @return String - major.minor version or empty string if invalid
 */
helper extractMajorMinorVersion(version : String) : String {
	// Find first dot
	var firstDot : Integer := version.indexOf('.');
	if firstDot <= 0 then
		return ''
	endif;
	
	// Find second dot (if exists)
	var afterFirstDot : String := version.substring(firstDot + 1, version.size());
	var secondDot : Integer := afterFirstDot.indexOf('.');
	
	if secondDot > 0 then
		// Version has patch number, extract major.minor
		// firstDot + secondDot gives us the position up to minor version
		return version.substring(1, firstDot + secondDot)
	else
		// Version is already major.minor
		return version
	endif;
}