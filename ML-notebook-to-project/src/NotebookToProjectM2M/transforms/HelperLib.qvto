import CodeClassificationLib;

library HelperLib;

modeltype NotebookMM uses "http://www.g7.org/notebookMM";
modeltype ProjectStuctureMM uses "http://www.g7.org/projectStructureMM";

/**
 * Returns the main.py entry point content that imports from preprocess, train, and predict modules.
 * @return Sequence(String)
 */
helper generateMainPyEntryContent(notebook : NotebookMM::NotebookModel) : Sequence(String) {
    var contentLines : Sequence(String) := Sequence{};
    
    // Add docstring from first markdown cell if available
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::MarkdownCell) then {
            var mdCell := cell.oclAsType(NotebookMM::MarkdownCell);
            if mdCell.content <> null and mdCell.content <> '' then {
                contentLines += '"""';
                contentLines += mdCell.content;
                contentLines += '"""';
                contentLines += '';
                break;
            } endif;
        } endif;
    };
    
    // Add imports from the stage modules
    contentLines += '# Import stage modules';
    contentLines += 'from preprocess import run_preprocessing';
    contentLines += 'from train import run_training';
    contentLines += 'from predict import run_prediction';
    contentLines += '';
    contentLines += '';
    contentLines += 'def main():';
    contentLines += '    """';
    contentLines += '    Main entry point that orchestrates the ML pipeline.';
    contentLines += '    Executes preprocessing, training, and prediction stages in sequence.';
    contentLines += '    """';
    contentLines += '    print("Starting ML Pipeline...")';
    contentLines += '    ';
    contentLines += '    print("\\n=== Preprocessing Stage ===")';
    contentLines += '    run_preprocessing()';
    contentLines += '    ';
    contentLines += '    print("\\n=== Training Stage ===")';
    contentLines += '    run_training()';
    contentLines += '    ';
    contentLines += '    print("\\n=== Prediction Stage ===")';
    contentLines += '    run_prediction()';
    contentLines += '    ';
    contentLines += '    print("\\nML Pipeline completed!")';
    contentLines += '';
    contentLines += '';
    contentLines += 'if __name__ == "__main__":';
    contentLines += '    main()';
    contentLines += '';
    
    return contentLines;
}

/**
 * Returns the content for preprocess.py containing preprocessing code blocks.
 * @return Sequence(String)
 */
helper generatePreprocessPyContent(notebook : NotebookMM::NotebookModel) : Sequence(String) {
    var contentLines : Sequence(String) := Sequence{};
    
    contentLines += '"""';
    contentLines += 'Preprocessing module - Contains data loading and preprocessing logic.';
    contentLines += '"""';
    contentLines += '';
    
    // Collect all imports from the notebook
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' and codeCell.isDataPreprocessing() then {
                codeCell.extractImports()->forEach(imp) {
                    contentLines += imp;
                };
            } endif;
        } endif;
    };
    
    contentLines += '';
    contentLines += '';
    contentLines += 'def run_preprocessing():';
    contentLines += '    """';
    contentLines += '    Execute all preprocessing steps.';
    contentLines += '    """';
    
    // Collect preprocessing code blocks
    var hasPreprocessCode : Boolean := false;
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' and codeCell.isDataPreprocessing() then {
                hasPreprocessCode := true;
                // Add preceding markdown as comment
                contentLines += '';
                contentLines += '    # Preprocessing code block';
                // Indent the code for the function body
                codeCell.getSourceLines()->forEach(line) {
                    contentLines += '    ' + line;
                };
            } endif;
        } endif;
    };
    
    if not hasPreprocessCode then {
        contentLines += '    pass  # No preprocessing code blocks found';
    } endif;
    
    contentLines += '';
    
    return contentLines;
}

/**
 * Returns the content for train.py containing training code blocks.
 * @return Sequence(String)
 */
helper generateTrainPyContent(notebook : NotebookMM::NotebookModel) : Sequence(String) {
    var contentLines : Sequence(String) := Sequence{};
    
    contentLines += '"""';
    contentLines += 'Training module - Contains model training logic.';
    contentLines += '"""';
    contentLines += '';
    
    // Collect all imports from the notebook
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' and codeCell.isTrainingCode() then {
                codeCell.extractImports()->forEach(imp) {
                    contentLines += imp;
                };
            } endif;
        } endif;
    };
    
    contentLines += '';
    contentLines += '';
    contentLines += 'def run_training():';
    contentLines += '    """';
    contentLines += '    Execute all training steps.';
    contentLines += '    """';
    
    // Collect training code blocks
    var hasTrainCode : Boolean := false;
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' and codeCell.isTrainingCode() then {
                hasTrainCode := true;
                // Add preceding markdown as comment
                contentLines += '';
                contentLines += '    # Training code block';
                // Indent the code for the function body
                codeCell.getSourceLines()->forEach(line) {
                    contentLines += '    ' + line;
                };
            } endif;
        } endif;
    };
    
    if not hasTrainCode then {
        contentLines += '    pass  # No training code blocks found';
    } endif;
    
    contentLines += '';
    
    return contentLines;
}

/**
 * Returns the content for predict.py containing prediction code blocks.
 * @return Sequence(String)
 */
helper generatePredictPyContent(notebook : NotebookMM::NotebookModel) : Sequence(String) {
    var contentLines : Sequence(String) := Sequence{};
    
    contentLines += '"""';
    contentLines += 'Prediction module - Contains model prediction/inference logic.';
    contentLines += '"""';
    contentLines += '';
    
    // Collect all imports from the notebook
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' and codeCell.isPredictionCode() then {
                codeCell.extractImports()->forEach(imp) {
                    contentLines += imp;
                };
            } endif;
        } endif;
    };
    
    contentLines += '';
    contentLines += '';
    contentLines += 'def run_prediction():';
    contentLines += '    """';
    contentLines += '    Execute all prediction steps.';
    contentLines += '    """';
    
    // Collect prediction code blocks
    var hasPredictCode : Boolean := false;
    notebook.cells->forEach(cell) {
        if cell.oclIsTypeOf(NotebookMM::CodeCell) then {
            var codeCell := cell.oclAsType(NotebookMM::CodeCell);
            if codeCell.source <> null and codeCell.source <> '' and codeCell.isPredictionCode() then {
                hasPredictCode := true;
                // Add preceding markdown as comment
                contentLines += '';
                contentLines += '    # Prediction code block';
                // Indent the code for the function body
                codeCell.getSourceLines()->forEach(line) {
                    contentLines += '    ' + line;
                };
            } endif;
        } endif;
    };
    
    if not hasPredictCode then {
        contentLines += '    pass  # No prediction code blocks found';
    } endif;
    
    contentLines += '';
    
    return contentLines;
}

/**
 * Returns an OrderedSet of String names of imported packages in python for pip to install.
 * @return OrderedSet(String)
 */
helper extractPackageNames(notebook : NotebookMM::NotebookModel) : OrderedSet(String) {
	var imports : OrderedSet(String) := notebook.getAllImports();
	var packages : OrderedSet(String) := 
		imports 
		->collect(importStmt | mapImportToPackage(importStmt)) 
		->select(pkg | pkg <> '') 
		->asOrderedSet(); 
	
	return packages;
}

/**
 * Returns the assumed String name of a package.
 * @return String
 */
helper mapImportToPackage(importStmt : String) : String {
	if importStmt.indexOf('sklearn') > 0 then
	return 'scikit-learn'
	elif importStmt.indexOf('cv2') > 0 then
	return 'opencv-python'
	elif importStmt.indexOf('PIL') > 0 then
	return 'Pillow'
	elif importStmt.indexOf('pandas') > 0 then
	return 'pandas'
	elif importStmt.indexOf('numpy') > 0 then
	return 'numpy'
	elif importStmt.indexOf('matplotlib') > 0 then
	return 'matplotlib'
	elif importStmt.indexOf('scipy') > 0 then
	return 'scipy'
	elif importStmt.indexOf('seaborn') > 0 then
	return 'seaborn'
	elif importStmt.indexOf('joblib') > 0 then
	return 'joblib'
	elif importStmt.indexOf('tensorflow') > 0 then
	return 'tensorflow'
	elif importStmt.indexOf('torch') > 0 then
	return 'torch'
	elif importStmt.indexOf('keras') > 0 then
	return 'keras'
	elif importStmt.indexOf('flask') > 0 then
	return 'flask'
	elif importStmt.indexOf('django') > 0 then
	return 'django'
	elif importStmt.indexOf('requests') > 0 then
	return 'requests'
	elif importStmt.indexOf('sqlalchemy') > 0 then
	return 'sqlalchemy'
	elif importStmt.indexOf('pytest') > 0 then
	return 'pytest'
	elif importStmt.indexOf('yaml') > 0 then
	return 'PyYAML'
	elif importStmt.indexOf('bs4') > 0 then
	return 'beautifulsoup4'
	elif importStmt.indexOf('dateutil') > 0 then
	return 'python-dateutil'
	else
	return ''
	endif
}