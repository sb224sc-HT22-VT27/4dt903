import CodeClassificationLib;
import HelperLib;

modeltype NotebookMM uses "http://www.g7.org/notebookMM";
modeltype ProjectStuctureMM uses "http://www.g7.org/projectStructureMM";

transformation NotebookToProject(in srcModel : NotebookMM, out targetModel : ProjectStuctureMM);

// property NAME : TYPE = val; Consts
property MAIN_FILE_NAME : String = "main.py";
property DIR_NAMES : Sequence(String) = Sequence{"data", "src", "models", "outputs"};
property REQUIREMENTS_FILE_NAME : String = "requirements.txt";
property DOCKERFILE_NAME : String = "Dockerfile";

main() {
	// [MetaModel::Attribute]
	srcModel.rootObjects()[NotebookMM::NotebookModel] -> map toProjectStructure();
}

mapping NotebookMM::NotebookModel::toProjectStructure() : ProjectStuctureMM::ProjectStructure {
	result.name := self.name;
	result.filesystemelement := DIR_NAMES->collect(dirName | self.map toDirectory(dirName))->union(Sequence{self.map toRequirementsFile(), self.map toDockerfile()});
}

mapping NotebookMM::NotebookModel::toDirectory(dirName : String) : ProjectStuctureMM::Directory {
    result.name := dirName;
    result.filesystemelement := if dirName = 'src' then OrderedSet{self.map toMainFile()} else OrderedSet{self.map toKeepFile()} endif;
}

mapping NotebookMM::NotebookModel::toMainFile() : ProjectStuctureMM::File {
    result.name := MAIN_FILE_NAME;
    result.content := generateMainPyContent(self);
}

mapping NotebookMM::NotebookModel::toRequirementsFile() : ProjectStuctureMM::File {
	result.name := REQUIREMENTS_FILE_NAME;
	result.content := extractPackageNames(self);
}

mapping NotebookMM::NotebookModel::toKeepFile() : ProjectStuctureMM::File {
	result.name := ".keep";
	result.content := OrderedSet{};
}

mapping NotebookMM::NotebookModel::toDockerfile() : ProjectStuctureMM::File {
	result.name := DOCKERFILE_NAME;
	result.content := generateDockerfileContent(self);
}

