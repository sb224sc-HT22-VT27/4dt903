<?xml version="1.0" encoding="ASCII"?>
<notebookMM:NotebookModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:notebookMM="http://www.g7.org/notebookMM" name="image_classification_cnn">
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_0" content="# Image Classification with CNN&#xA;Training a convolutional neural network for product category classification"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_1" source="import os&#xA;import numpy as np&#xA;import pandas as pd&#xA;import matplotlib.pyplot as plt&#xA;import tensorflow as tf&#xA;from tensorflow import keras&#xA;from tensorflow.keras import layers&#xA;from tensorflow.keras.preprocessing.image import ImageDataGenerator&#xA;from sklearn.metrics import confusion_matrix, classification_report&#xA;import seaborn as sns&#xA;import json">
    <imports>import os</imports>
    <imports>import numpy as np</imports>
    <imports>import pandas as pd</imports>
    <imports>import matplotlib.pyplot as plt</imports>
    <imports>import tensorflow as tf</imports>
    <imports>from tensorflow import keras</imports>
    <imports>from tensorflow.keras import layers</imports>
    <imports>from tensorflow.keras.preprocessing.image import ImageDataGenerator</imports>
    <imports>from sklearn.metrics import confusion_matrix, classification_report</imports>
    <imports>import seaborn as sns</imports>
    <imports>import json</imports>
  </cells>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_2" content="## Configuration"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_3" source="# Hyperparameters&#xA;IMG_SIZE = 224&#xA;BATCH_SIZE = 32&#xA;EPOCHS = 50&#xA;LEARNING_RATE = 0.001&#xA;NUM_CLASSES = 10&#xA;&#xA;# Paths&#xA;TRAIN_DIR = 'data/train'&#xA;VAL_DIR = 'data/validation'&#xA;TEST_DIR = 'data/test'&#xA;MODEL_PATH = 'models/product_classifier.keras'&#xA;HISTORY_PATH = 'output/training_history.json'&#xA;&#xA;print(f&quot;Using TensorFlow version: {tf.__version__}&quot;)&#xA;print(f&quot;GPU Available: {tf.config.list_physical_devices('GPU')}&quot;)"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_4" content="## Data Loading and Augmentation"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_5" source="# Data augmentation for training&#xA;train_datagen = ImageDataGenerator(&#xA;    rescale=1./255,&#xA;    rotation_range=20,&#xA;    width_shift_range=0.2,&#xA;    height_shift_range=0.2,&#xA;    horizontal_flip=True,&#xA;    zoom_range=0.2,&#xA;    shear_range=0.2,&#xA;    fill_mode='nearest'&#xA;)&#xA;&#xA;# Only rescaling for validation and test&#xA;val_datagen = ImageDataGenerator(rescale=1./255)&#xA;test_datagen = ImageDataGenerator(rescale=1./255)&#xA;&#xA;# Load datasets&#xA;train_generator = train_datagen.flow_from_directory(&#xA;    TRAIN_DIR,&#xA;    target_size=(IMG_SIZE, IMG_SIZE),&#xA;    batch_size=BATCH_SIZE,&#xA;    class_mode='categorical'&#xA;)&#xA;&#xA;val_generator = val_datagen.flow_from_directory(&#xA;    VAL_DIR,&#xA;    target_size=(IMG_SIZE, IMG_SIZE),&#xA;    batch_size=BATCH_SIZE,&#xA;    class_mode='categorical'&#xA;)&#xA;&#xA;test_generator = test_datagen.flow_from_directory(&#xA;    TEST_DIR,&#xA;    target_size=(IMG_SIZE, IMG_SIZE),&#xA;    batch_size=BATCH_SIZE,&#xA;    class_mode='categorical',&#xA;    shuffle=False&#xA;)&#xA;&#xA;print(f&quot;Training samples: {train_generator.samples}&quot;)&#xA;print(f&quot;Validation samples: {val_generator.samples}&quot;)&#xA;print(f&quot;Test samples: {test_generator.samples}&quot;)&#xA;print(f&quot;Class labels: {train_generator.class_indices}&quot;)"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_6" content="## Model Architecture"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_7" source="def build_cnn_model(input_shape, num_classes):&#xA;    &quot;&quot;&quot;&#xA;    Build a CNN model for image classification&#xA;    &quot;&quot;&quot;&#xA;    model = keras.Sequential([&#xA;        # Block 1&#xA;        layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),&#xA;        layers.BatchNormalization(),&#xA;        layers.MaxPooling2D((2, 2)),&#xA;        layers.Dropout(0.25),&#xA;&#xA;        # Block 2&#xA;        layers.Conv2D(64, (3, 3), activation='relu'),&#xA;        layers.BatchNormalization(),&#xA;        layers.MaxPooling2D((2, 2)),&#xA;        layers.Dropout(0.25),&#xA;&#xA;        # Block 3&#xA;        layers.Conv2D(128, (3, 3), activation='relu'),&#xA;        layers.BatchNormalization(),&#xA;        layers.MaxPooling2D((2, 2)),&#xA;        layers.Dropout(0.25),&#xA;&#xA;        # Block 4&#xA;        layers.Conv2D(256, (3, 3), activation='relu'),&#xA;        layers.BatchNormalization(),&#xA;        layers.MaxPooling2D((2, 2)),&#xA;        layers.Dropout(0.25),&#xA;&#xA;        # Dense layers&#xA;        layers.Flatten(),&#xA;        layers.Dense(512, activation='relu'),&#xA;        layers.BatchNormalization(),&#xA;        layers.Dropout(0.5),&#xA;        layers.Dense(256, activation='relu'),&#xA;        layers.Dropout(0.3),&#xA;        layers.Dense(num_classes, activation='softmax')&#xA;    ])&#xA;&#xA;    return model&#xA;&#xA;# Build model&#xA;model = build_cnn_model(&#xA;    input_shape=(IMG_SIZE, IMG_SIZE, 3),&#xA;    num_classes=NUM_CLASSES&#xA;)&#xA;&#xA;model.summary()"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_8" content="## Compile Model"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_9" source="# Compile model&#xA;optimizer = keras.optimizers.Adam(learning_rate=LEARNING_RATE)&#xA;&#xA;model.compile(&#xA;    optimizer=optimizer,&#xA;    loss='categorical_crossentropy',&#xA;    metrics=['accuracy', keras.metrics.TopKCategoricalAccuracy(k=3)]&#xA;)&#xA;&#xA;print(&quot;Model compiled successfully!&quot;)"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_10" content="## Callbacks"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_11" source="# Early stopping&#xA;early_stopping = keras.callbacks.EarlyStopping(&#xA;    monitor='val_loss',&#xA;    patience=10,&#xA;    restore_best_weights=True&#xA;)&#xA;&#xA;# Learning rate reduction&#xA;reduce_lr = keras.callbacks.ReduceLROnPlateau(&#xA;    monitor='val_loss',&#xA;    factor=0.5,&#xA;    patience=5,&#xA;    min_lr=1e-7&#xA;)&#xA;&#xA;# Model checkpoint&#xA;checkpoint = keras.callbacks.ModelCheckpoint(&#xA;    'models/best_model.keras',&#xA;    monitor='val_accuracy',&#xA;    save_best_only=True&#xA;)&#xA;&#xA;callbacks = [early_stopping, reduce_lr, checkpoint]"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_12" content="## Train Model"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_13" source="# Train the model&#xA;history = model.fit(&#xA;    train_generator,&#xA;    validation_data=val_generator,&#xA;    epochs=EPOCHS,&#xA;    callbacks=callbacks,&#xA;    verbose=1&#xA;)&#xA;&#xA;print(&quot;Training completed!&quot;)"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_14" content="## Plot Training History"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_15" source="# Plot training &amp; validation accuracy&#xA;plt.figure(figsize=(12, 4))&#xA;&#xA;plt.subplot(1, 2, 1)&#xA;plt.plot(history.history['accuracy'], label='Train Accuracy')&#xA;plt.plot(history.history['val_accuracy'], label='Val Accuracy')&#xA;plt.title('Model Accuracy')&#xA;plt.xlabel('Epoch')&#xA;plt.ylabel('Accuracy')&#xA;plt.legend()&#xA;plt.grid(True)&#xA;&#xA;plt.subplot(1, 2, 2)&#xA;plt.plot(history.history['loss'], label='Train Loss')&#xA;plt.plot(history.history['val_loss'], label='Val Loss')&#xA;plt.title('Model Loss')&#xA;plt.xlabel('Epoch')&#xA;plt.ylabel('Loss')&#xA;plt.legend()&#xA;plt.grid(True)&#xA;&#xA;plt.tight_layout()&#xA;plt.savefig('output/training_history.png')&#xA;plt.show()"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_16" content="## Evaluate on Test Set"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_17" source="# Evaluate on test set&#xA;test_loss, test_acc, test_top3_acc = model.evaluate(test_generator)&#xA;print(f&quot;\nTest Accuracy: {test_acc:.4f}&quot;)&#xA;print(f&quot;Test Top-3 Accuracy: {test_top3_acc:.4f}&quot;)&#xA;print(f&quot;Test Loss: {test_loss:.4f}&quot;)&#xA;&#xA;# Get predictions&#xA;predictions = model.predict(test_generator)&#xA;y_pred = np.argmax(predictions, axis=1)&#xA;y_true = test_generator.classes&#xA;&#xA;# Classification report&#xA;class_names = list(test_generator.class_indices.keys())&#xA;print(&quot;\nClassification Report:&quot;)&#xA;print(classification_report(y_true, y_pred, target_names=class_names))"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_18" content="## Confusion Matrix"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_19" source="# Plot confusion matrix&#xA;cm = confusion_matrix(y_true, y_pred)&#xA;&#xA;plt.figure(figsize=(12, 10))&#xA;sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',&#xA;            xticklabels=class_names,&#xA;            yticklabels=class_names)&#xA;plt.title('Confusion Matrix')&#xA;plt.ylabel('True Label')&#xA;plt.xlabel('Predicted Label')&#xA;plt.tight_layout()&#xA;plt.savefig('output/confusion_matrix.png')&#xA;plt.show()"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_20" content="## Save Model and Metadata"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_21" source="# Save final model&#xA;model.save(MODEL_PATH)&#xA;print(f&quot;Model saved to {MODEL_PATH}&quot;)&#xA;&#xA;# Save training history&#xA;with open(HISTORY_PATH, 'w') as f:&#xA;    json.dump(history.history, f)&#xA;&#xA;# Save class indices&#xA;with open('models/class_indices.json', 'w') as f:&#xA;    json.dump(train_generator.class_indices, f)&#xA;&#xA;# Save model metadata&#xA;metadata = {&#xA;    'img_size': IMG_SIZE,&#xA;    'num_classes': NUM_CLASSES,&#xA;    'test_accuracy': float(test_acc),&#xA;    'test_loss': float(test_loss),&#xA;    'class_names': class_names&#xA;}&#xA;&#xA;with open('models/model_metadata.json', 'w') as f:&#xA;    json.dump(metadata, f, indent=2)&#xA;&#xA;print(&quot;Metadata saved!&quot;)"/>
  <cells xsi:type="notebookMM:MarkdownCell" cellType="MARKDOWN" id="cell_22" content="## Inference Function"/>
  <cells xsi:type="notebookMM:CodeCell" id="cell_23" source="def predict_image(image_path, model_path='models/product_classifier.keras'):&#xA;    &quot;&quot;&quot;&#xA;    Predict class for a single image&#xA;    &quot;&quot;&quot;&#xA;    # Load model&#xA;    model = keras.models.load_model(model_path)&#xA;&#xA;    # Load and preprocess image&#xA;    img = keras.preprocessing.image.load_img(&#xA;        image_path,&#xA;        target_size=(IMG_SIZE, IMG_SIZE)&#xA;    )&#xA;    img_array = keras.preprocessing.image.img_to_array(img)&#xA;    img_array = img_array / 255.0&#xA;    img_array = np.expand_dims(img_array, axis=0)&#xA;&#xA;    # Predict&#xA;    predictions = model.predict(img_array)&#xA;    predicted_class = np.argmax(predictions[0])&#xA;    confidence = predictions[0][predicted_class]&#xA;&#xA;    # Load class names&#xA;    with open('models/class_indices.json', 'r') as f:&#xA;        class_indices = json.load(f)&#xA;&#xA;    # Reverse mapping&#xA;    idx_to_class = {v: k for k, v in class_indices.items()}&#xA;    predicted_label = idx_to_class[predicted_class]&#xA;&#xA;    return predicted_label, confidence, predictions[0]&#xA;&#xA;# Test the function&#xA;test_image = 'data/test/sample_product.jpg'&#xA;label, conf, probs = predict_image(test_image)&#xA;print(f&quot;\nPredicted class: {label}&quot;)&#xA;print(f&quot;Confidence: {conf:.4f}&quot;)&#xA;# print(f&quot;Probs: {probs}&quot;)"/>
  <metadata kernelspec="python3" language="python" nbformat="4"/>
</notebookMM:NotebookModel>
